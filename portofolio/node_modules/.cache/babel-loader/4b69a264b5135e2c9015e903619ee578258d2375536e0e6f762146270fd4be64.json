{"ast":null,"code":"// utils.js\n\n// Generate a random integer between min and max (inclusive)\nexport const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\nexport const generateNonOverlappingPosition = (size, existingPositions, containerSize, originalPosition) => {\n  let position;\n  let overlap;\n  const maxAttempts = 1000;\n  let attempts = 0;\n  console.log(`Generating non-overlapping position for size ${size} within container ${containerSize.width}x${containerSize.height}`);\n  do {\n    overlap = false;\n    let xmin = originalPosition.x - containerSize.width;\n    let xmax = originalPosition.x + containerSize.width;\n    let ymin = originalPosition.y - containerSize.height;\n    let ymax = originalPosition.y + containerSize.height;\n    xmin = xmin < size ? size : xmin;\n    ymin = ymin < size ? size : ymin;\n    xmax = xmax > containerSize.width - size ? containerSize.width - size : xmax;\n    ymax = ymax > containerSize.height - size ? containerSize.height - size : ymax;\n    position = {\n      x: getRandomInt(xmin - size, xmax - size),\n      y: getRandomInt(ymin - size, ymax - size)\n    };\n    for (let existing of existingPositions) {\n      if (Math.abs(position.x - existing.x) < size && Math.abs(position.y - existing.y) < size) {\n        overlap = true;\n        break;\n      }\n    }\n    attempts++;\n  } while (overlap && attempts < maxAttempts);\n  console.log(`Generated position: ${position.x}, ${position.y} after ${attempts} attempts for large bubble at ${originalPosition.x}, ${originalPosition.y}, ymax is ${originalPosition.y + containerSize.height}, xmax is ${originalPosition.x + containerSize.width}, ymin is ${originalPosition.y - containerSize.height}, xmin is ${originalPosition.x - containerSize.width}`);\n  return position;\n};","map":{"version":3,"names":["getRandomInt","min","max","Math","floor","random","generateNonOverlappingPosition","size","existingPositions","containerSize","originalPosition","position","overlap","maxAttempts","attempts","console","log","width","height","xmin","x","xmax","ymin","y","ymax","existing","abs"],"sources":["C:/Users/ZiQi/Desktop/新建文件夹/portofolio/portofolio/src/Components/Skills/utils.js"],"sourcesContent":["// utils.js\r\n\r\n// Generate a random integer between min and max (inclusive)\r\nexport const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\r\n\r\nexport const generateNonOverlappingPosition = (size, existingPositions, containerSize, originalPosition) => {\r\n  let position;\r\n  let overlap;\r\n  const maxAttempts = 1000;\r\n  let attempts = 0;\r\n\r\n  console.log(`Generating non-overlapping position for size ${size} within container ${containerSize.width}x${containerSize.height}`);\r\n\r\n  do {\r\n    overlap = false;\r\n    let xmin = originalPosition.x - containerSize.width;\r\n    let xmax = originalPosition.x + containerSize.width;\r\n    let ymin = originalPosition.y - containerSize.height;\r\n    let ymax = originalPosition.y + containerSize.height;\r\n    xmin = xmin < size ? size : xmin;\r\n    ymin = ymin < size ? size : ymin;\r\n    xmax = xmax > containerSize.width - size ? containerSize.width - size : xmax;\r\n    ymax = ymax > containerSize.height - size ? containerSize.height - size : ymax;\r\n    position = {\r\n      x: getRandomInt(xmin-size, xmax-size),\r\n      y: getRandomInt(ymin-size, ymax-size)\r\n    };\r\n    for (let existing of existingPositions) {\r\n      if (Math.abs(position.x - existing.x) < size && Math.abs(position.y - existing.y) < size) {\r\n        overlap = true;\r\n        break;\r\n      }\r\n    }\r\n    attempts++;\r\n  } while (overlap && attempts < maxAttempts);\r\n\r\n  console.log(`Generated position: ${position.x}, ${position.y} after ${attempts} attempts for large bubble at ${originalPosition.x}, ${originalPosition.y}, ymax is ${originalPosition.y + containerSize.height}, xmax is ${originalPosition.x + containerSize.width}, ymin is ${originalPosition.y - containerSize.height}, xmin is ${originalPosition.x - containerSize.width}`);\r\n\r\n  return position;\r\n};\r\n"],"mappings":"AAAA;;AAEA;AACA,OAAO,MAAMA,YAAY,GAAGA,CAACC,GAAG,EAAEC,GAAG,KAAKC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIH,GAAG,GAAGD,GAAG,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG;AAE3F,OAAO,MAAMK,8BAA8B,GAAGA,CAACC,IAAI,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,KAAK;EAC1G,IAAIC,QAAQ;EACZ,IAAIC,OAAO;EACX,MAAMC,WAAW,GAAG,IAAI;EACxB,IAAIC,QAAQ,GAAG,CAAC;EAEhBC,OAAO,CAACC,GAAG,CAAC,gDAAgDT,IAAI,qBAAqBE,aAAa,CAACQ,KAAK,IAAIR,aAAa,CAACS,MAAM,EAAE,CAAC;EAEnI,GAAG;IACDN,OAAO,GAAG,KAAK;IACf,IAAIO,IAAI,GAAGT,gBAAgB,CAACU,CAAC,GAAGX,aAAa,CAACQ,KAAK;IACnD,IAAII,IAAI,GAAGX,gBAAgB,CAACU,CAAC,GAAGX,aAAa,CAACQ,KAAK;IACnD,IAAIK,IAAI,GAAGZ,gBAAgB,CAACa,CAAC,GAAGd,aAAa,CAACS,MAAM;IACpD,IAAIM,IAAI,GAAGd,gBAAgB,CAACa,CAAC,GAAGd,aAAa,CAACS,MAAM;IACpDC,IAAI,GAAGA,IAAI,GAAGZ,IAAI,GAAGA,IAAI,GAAGY,IAAI;IAChCG,IAAI,GAAGA,IAAI,GAAGf,IAAI,GAAGA,IAAI,GAAGe,IAAI;IAChCD,IAAI,GAAGA,IAAI,GAAGZ,aAAa,CAACQ,KAAK,GAAGV,IAAI,GAAGE,aAAa,CAACQ,KAAK,GAAGV,IAAI,GAAGc,IAAI;IAC5EG,IAAI,GAAGA,IAAI,GAAGf,aAAa,CAACS,MAAM,GAAGX,IAAI,GAAGE,aAAa,CAACS,MAAM,GAAGX,IAAI,GAAGiB,IAAI;IAC9Eb,QAAQ,GAAG;MACTS,CAAC,EAAEpB,YAAY,CAACmB,IAAI,GAACZ,IAAI,EAAEc,IAAI,GAACd,IAAI,CAAC;MACrCgB,CAAC,EAAEvB,YAAY,CAACsB,IAAI,GAACf,IAAI,EAAEiB,IAAI,GAACjB,IAAI;IACtC,CAAC;IACD,KAAK,IAAIkB,QAAQ,IAAIjB,iBAAiB,EAAE;MACtC,IAAIL,IAAI,CAACuB,GAAG,CAACf,QAAQ,CAACS,CAAC,GAAGK,QAAQ,CAACL,CAAC,CAAC,GAAGb,IAAI,IAAIJ,IAAI,CAACuB,GAAG,CAACf,QAAQ,CAACY,CAAC,GAAGE,QAAQ,CAACF,CAAC,CAAC,GAAGhB,IAAI,EAAE;QACxFK,OAAO,GAAG,IAAI;QACd;MACF;IACF;IACAE,QAAQ,EAAE;EACZ,CAAC,QAAQF,OAAO,IAAIE,QAAQ,GAAGD,WAAW;EAE1CE,OAAO,CAACC,GAAG,CAAC,uBAAuBL,QAAQ,CAACS,CAAC,KAAKT,QAAQ,CAACY,CAAC,UAAUT,QAAQ,iCAAiCJ,gBAAgB,CAACU,CAAC,KAAKV,gBAAgB,CAACa,CAAC,aAAab,gBAAgB,CAACa,CAAC,GAAGd,aAAa,CAACS,MAAM,aAAaR,gBAAgB,CAACU,CAAC,GAAGX,aAAa,CAACQ,KAAK,aAAaP,gBAAgB,CAACa,CAAC,GAAGd,aAAa,CAACS,MAAM,aAAaR,gBAAgB,CAACU,CAAC,GAAGX,aAAa,CAACQ,KAAK,EAAE,CAAC;EAEjX,OAAON,QAAQ;AACjB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}